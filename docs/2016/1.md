---
day: 1
title: Day 1
main_img:
  name: No Time for a Taxicab
  link: /assets/images/2016-01.png
tags: 
  - name: Unit Circle
    link: https://www.mathsisfun.com/geometry/unit-circle.html
  - name: Taxicab Geometry
    link: https://en.wikipedia.org/wiki/Taxicab_geometry
  - name: list.count()
    link: https://docs.python.org/3/tutorial/datastructures.html#more-on-lists
  - name: Logging
    link: /python/logging
  - name: os.path
    link: https://docs.python.org/3/library/os.path.html
  - name: time.perf_counter
    link: https://docs.python.org/3/library/time.html#time.perf_counter
---

## Problem Intro

Welcome to Advent of Code 2016, Day 1! In this puzzle, you're airdropped near Easter Bunny Headquarters in a city with a grid-like street layout. You start at coordinates (0,0) facing North. You're given a sequence of instructions, each telling you to either turn left (L) or right (R) 90 degrees, and then walk forward a specified number of blocks.

The input data looks like a comma-separated string of instructions, for example:

```text
R2, L3, R2, R2, R2, R5, L5, R5, R3
```

## Part 1

**How many blocks away is Easter Bunny HQ?**

For Part 1, the goal is to determine the "taxicab distance" (also known as Manhattan distance) to the final destination after following all instructions. This means summing the absolute differences of the final X and Y coordinates from the starting point (0,0).

My solution uses a `location` dictionary to keep track of the current `x` and `y` coordinates, and a `heading` variable (0 for North, 90 for East, 180 for South, 270 for West) to represent the current direction.

The core logic resides in the `process_direction` function:

```python
def process_direction(location: dict, visited_locations: list, heading: int, instr: str):
    turn = instr[0]
    magnitude = int(instr[1:])
    rotation = 90 if turn == 'R' else -90
    heading = convert_angle(heading + rotation)
    
    # We need to process the instruction one unit at a time, 
    # so that we store the path taken, not just the final landing location of each instruction
    for _ in range(magnitude):
        # unit circle geometry
        location[X] += round(sin(radians(heading)))
        location[Y] += round(cos(radians(heading)))
        
        # store all coords visited whilst following this direction
        visited_locations.append(location.copy())
    
    return location, heading

def convert_angle(angle: int):
    """ Convert any angle to %360

    Args:
        angle (int): An angle

    Returns:
        [int]: The angle
    """
    if (angle < 0):
        angle += 360
    
    return angle % 360
```

-   The `turn` (L or R) determines the `rotation` (90 or -90 degrees).
-   The `heading` is updated and normalized using `convert_angle` to stay within 0-359 degrees.
-   **Unit Circle Geometry:** The change in `x` and `y` coordinates is calculated using `sin` and `cos` of the `heading`. For example, if `heading` is 0 (North), `sin(0)` is 0 and `cos(0)` is 1, so `x` doesn't change and `y` increases by 1. If `heading` is 90 (East), `sin(90)` is 1 and `cos(90)` is 0, so `x` increases by 1 and `y` doesn't change.
-   The `magnitude` (number of blocks to walk) is processed one unit at a time. This is crucial for Part 2, as it allows us to record every intermediate step.

After all instructions are processed, the taxicab distance is simply `abs(final_x) + abs(final_y)`.

## Part 2

**What is the distance to the first location you visit twice?**

For Part 2, the challenge is to find the very first location that is visited more than once. This includes all intermediate steps taken during movement.

My solution addresses this by maintaining a `visited_locations` list. As shown in the `process_direction` function above, for each block walked, the current `location` is appended to this list. This creates a complete history of the path taken.

After processing all instructions, the code iterates through the `visited_locations` list to find the first coordinate that appears more than once. The `list.count()` method is used for this purpose.

```python
    for visited in visited_locations:
        # we want the first location that was visited twice
        # i.e. where this particular location has a count > 1
        if visited_locations.count(visited) > 1:
            taxicab_distance = abs(visited[X]) + abs(visited[Y])
            logging.info(f"First location visited twice was {visited}")
            logging.info(f"Distance to this location: {taxicab_distance}")
            break
```

The `list.count(element)` method returns the number of times `element` appears in the list. By iterating through `visited_locations` and checking `count(visited) > 1`, the first such `visited` location found is the answer to Part 2.

## Results

The execution of the solution yields results that look something like this:

```text
Taxicab distance for entire journey: 230
First location visited twice was {'x': 116, 'y': 5}
Distance to this location: 121
Execution time: 0.0059 seconds
```
