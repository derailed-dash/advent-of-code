---
day: 2
title: Day 2
main_img:
  name: "Bathroom Security"
  link: /assets/images/bathroom-security.png
tags: 
  - name: numpy
    link: https://numpy.org/
  - name: 2D array
    link: https://www.programiz.com/python-programming/matrix
---

## Problem Intro

We need to find the code to a bathroom, and the instructions are a series of moves on a keypad. The input is a list of strings, where each string represents a sequence of moves. 'U' is up, 'D' is down, 'L' is left, and 'R' is right.

For example:
```
ULL
RRDDD
LURDL
UUUUD
```

We start at '5' on a standard 3x3 keypad. Each line of instructions gives us one digit of the code.

## Part 1

**What is the bathroom code?**

My approach is to represent the keypad as a 2D `numpy` array. This makes it easy to move around using array indices. I'll keep track of the current position (row and column) and update it based on the instructions. If a move would take me off the keypad, I'll ignore it.

### Why `numpy`?

For a puzzle like this that involves a grid and movement, `numpy` is an excellent choice. Here's why:

*   **Intuitive Representation:** A 2D `numpy` array is a natural and intuitive way to represent a grid or matrix, like the keypad in this puzzle.
*   **Efficient Indexing:** `numpy` provides fast and easy indexing to access and manipulate elements in the array. Moving up, down, left, or right is as simple as incrementing or decrementing the row and column indices.
*   **Array Properties:** `numpy` arrays have useful properties like `.shape`, which I use to get the dimensions of the keypad. This is helpful for checking if a move would go off the edge of the grid.
*   **Readability:** Using a `numpy` array can make the code more readable and easier to understand, as the data structure closely matches the problem description.

Here's the `get_combo` function that does the heavy lifting:

```python
def get_combo(keypad: np.ndarray, instructions: list, row: int, col: int) -> list:
    """ Process a list of keypad navigation instructions.
    At the end of each line, store the current button position.

    Args:
        keypad (np.ndarray): The 2D array that represents the keypad
        instructions (list): List of navigation instructions, in the format U, D, L, R
        row (int): The starting row.
        col (int): The starting col.

    Returns:
        list: The sequence of keypresses.
    """
    rows, cols = keypad.shape
    logging.debug(f"\n{keypad}")
    logging.debug(f"Starting button: {keypad[row, col]}")
    keypresses = []
    
    for line in instructions:
        for char in line:
            col += NavigationConstants.VECTORS[char][0]
            row += NavigationConstants.VECTORS[char][1]
            
            # if we've gone off the edge, then set the col and row to edge
            if col < 0: 
                col = 0
            if col > cols-1: 
                col = cols-1
            if row < 0: 
                row  = 0
            if row > rows-1: 
                row = rows-1
            
        keypresses.append(str(keypad[row][col]))
        
    return keypresses
```

I use a dictionary to map the 'U', 'D', 'L', 'R' characters to changes in the row and column indices. After each full line of instructions, I append the resulting keypad digit to my list of keypresses.

For Part 1, the keypad is a simple 3x3 grid. I use `np.arange(1, 10).reshape(3, 3)` to create this keypad.
*   `np.arange(1, 10)` creates a 1D array with the numbers 1 through 9.
*   `.reshape(3, 3)` then reshapes this 1D array into a 3x3 2D array.

```python
keypad = np.arange(1, 10).reshape(3, 3)
```

## Part 2

**What is the bathroom code using this new keypad?**

Part 2 introduces a more complex keypad:

```
    1
  2 3 4
5 6 7 8 9
  A B C
    D
```

I represent this as a 5x5 `numpy` array with spaces for the blank areas. This is where using a `numpy` array really shines, as it can handle non-numeric data and mixed data types (in this case, numbers, letters, and spaces).

```python
keypad = np.array([[" ", " ", "1", " ", " "],
                   [" ", "2", "3", "4", " "],
                   ["5", "6", "7", "8", "9"],
                   [" ", "A", "B", "C", " "],
                   [" ", " ", "D", " ", " "]])
```

The logic for moving around the keypad needs a small addition. If a move lands on a space, the move is invalid and I reverse it.

```python
            # if current array position is ' ', then reverse (ignore) last instruction
            if str(keypad[row][col]) == ' ':
                col -= NavigationConstants.VECTORS[char][0]
                row -= NavigationConstants.VECTORS[char][1]
```

The rest of the `get_combo` function remains the same. I just call it with the new keypad and a different starting position.

This `numpy`-based approach is quite clean and handles both parts of the puzzle with minimal code changes. The use of a 2D array is a natural fit for representing the keypad and makes the movement logic straightforward.
