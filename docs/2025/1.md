---
layout: day-page
day: 1
year: 2025
title: Day 1
main_img:
  name: "Safe Dial"
  link: /assets/images/2025-01.jpg
tags: 
  - name: Modular Arithmetic
    link: https://en.wikipedia.org/wiki/Modular_arithmetic
  - name: Integer Division
    link: https://realpython.com/python-operators-expressions/#arithmetic-operators
---

## Page Navigation

- [Problem Intro](#problem-intro)
- [Part 1](#part-1)
- [Part 2](#part-2)
- [The Bug Hunt](#the-bug-hunt)
- [Results](#results)

## Problem Intro

Welcome to Advent of Code 2025! I normally expect the first day to be a warm-up, but this one was a little tricky. Edge cases that were not included in the example input caught me out for a while.

We need to get into a safe to retrieve a password. The safe has a dial with numbers `0` through `99` arranged in a circle. The dial starts pointing at `50`. As you turn the dial, it makes a small **click** at each number position.

The input contains rotation instructions, one per line. Each instruction starts with:
- `L` (left/toward lower numbers) or `R` (right/toward higher numbers)
- Followed by a distance value (number of clicks)

For example:
```text
L68
L30
R48
L5
R60
```

The dial wraps around: turning left from `0` goes to `99`, and turning right from `99` goes to `0`.

Example rotations:
- From `11`, rotating `R8` → points at `19`
- From `19`, rotating `L19` → points at `0`
- From `5`, rotating `L10` → points at `95`

## Part 1

**What's the actual password to open the door?**

The password is **the number of times the dial ends at position `0` after any rotation**.

This is straightforward - we just need to track the dial position and count how many times we land on `0` after completing each rotation.

### Solution Approach

We can use modular arithmetic to handle the circular dial:
- For RIGHT rotations: `(position + steps) % 100`
- For LEFT rotations: `(position - steps) % 100`

Here's the core logic:

```python
def part1(data: list[str], start: int = 50, clicks: int = 100):
    zero_counter = 0
    curr_pos = start

    for instruction in data:
        direction = instruction[0]
        steps = int(instruction[1:])
        
        # Convert LEFT to equivalent RIGHT rotation
        if direction == "L":
            steps = clicks - steps
        
        curr_pos = (curr_pos + steps) % clicks
        if curr_pos == 0:
            zero_counter += 1

    return zero_counter
```

**Why convert LEFT to RIGHT?** This simplifies the logic. A left rotation of `n` steps is equivalent to a right rotation of `100 - n` steps on a dial with 100 positions.

## Part 2

**Using password method 0x434C49434B, what is the password to open the door?**

Now we need to count **every click** that lands on `0`, not just the final position after each rotation. This includes:
- Intermediate crossings during a rotation
- Final positions that land on `0`
- Multiple wraps around the dial in a single rotation

For example, `R1000` from position `50` would cross `0` ten times before returning to `50`.

### Solution Approach

Instead of simulating every single click (which would be slow), we can use mathematical formulas to count zero crossings:

**For RIGHT rotations:**
```python
zero_counter += (curr_pos + steps) // clicks
```

This counts how many times we pass position `0` (which happens at positions 100, 200, 300, etc.).

**For LEFT rotations:**
This is trickier! We need to handle three cases:

1. **Starting at `0`**: Only count complete loops
   ```python
   if curr_pos == 0:
       zero_counter += steps // clicks
   ```

2. **Landing exactly on `0`**: When `steps == curr_pos`
   ```python
   elif steps == curr_pos:
       zero_counter += 1
   ```

3. **Crossing `0` one or more times**: When `steps > curr_pos`
   ```python
   elif steps > curr_pos:
       zero_counter += ((steps - curr_pos - 1) // clicks) + 1
       # CRITICAL: If we also END on 0, count that final landing
       if new_pos == 0:
           zero_counter += 1
   ```

## The Bug Hunt

Getting Part 2 correct was a journey! Here's what happened:

### Initial Attempts
1. **First try Too Low**: Wasn't counting all zero crossings correctly
2. **Second try Too High**: Overcounting zeros when starting at position `0`
3. **Third try Still Wrong**: Undercounting LEFT rotations ending at `0`

### Root Cause

The formula `((steps - curr_pos - 1) // clicks) + 1` correctly counts how many times we **cross** the `0` boundary, but when we **end exactly on `0`**, that final landing wasn't being counted.

### The Fix

Added a check after calculating crossings for LEFT rotations:

```python
elif steps > curr_pos:
    zero_counter += ((steps - curr_pos - 1) // clicks) + 1
    # If we also END on 0, count that final landing
    if new_pos == 0:
        zero_counter += 1
```

## Results

The results look something like this:

```text
Part 1: 1001
Part 2: 6512
Execution time: 0.002 seconds
```

Both parts run in just 2 milliseconds!

**Why is this fast?** Instead of iterating through potentially thousands of clicks per rotation, we calculate the answer mathematically in constant time per instruction.
